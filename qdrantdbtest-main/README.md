# Инструкция

## Что будет выполнено в ходе инструкции:

1) Рассмотрены требования.
2) Выполнено развертывание виртуального окружения для работы скриптов.
3) Осуществлен запуск векторной БД QDRANT.
4) Выполнены парсинг данных со списка нужных страниц и наполнение БД этими данными.
5) Осуществлен запуск чат-бота, который будет отвечать на вопросы обращаясь к данным в развернутой ранее БД.

```
Внимание! На данном этапе все работает медленно, скрипты могут зависать или выдавать ошибки. 
Все не стабильно пока ) нужны оптимизация и рефакторинг по мере разработки.
```

## 1. Требования
```
Требования для запуска и работы:

- Для запуска потребуется минимум 3гб свободного места

- Модель, даже такая маленькая как Gemma3:1b, требовательна к ресурсам ЦП и оперативной памяти,
  поэтому для запуска в вм нужны будут 8-12гб ОЗУ, а также 4 физических ядра ЦП

- Все тестировалось на версии Python 3.10.12 
```

## 2. Развертывание виртуального окружения.

### Небольшое введение

Скрипт собирает данные из списка ссылок хранящихся в файле **urls.txt**, нарезает на чанки, преобразует в Embeddings согласно установленной в нем модели llm, затем помещает все в векторную БД QDRANT в конкретную коллекцию (название БД по сути).

Развертывание БД также будет рассмотрено ниже.


### Создаем виртуальное окружение для работы скрипта
```
python3 -m venv qdrant_kb
```

### Запускаем виртуальное окружение 
Запускаем созданное ранее виртуальное окружение
```
source qdrant_kb/bin/activate
```

### Устанавливаем зависимости 
После запуска виртуального окружения, устанавливаем все зависимости так:

Обновляем pip:
```
pip install --upgrade pip
```
Устанавливаем все зависимости разом (будет не быстро):
```
pip install -r requirements.txt
```

## 3. Запуск векторной БД QDRANT.
### Развертывание БД QDRANT.
Для этого я приложил docker-compose.yml который разворачивает локальную БД QDRANT в докере, для его запуска потребуется установленные **docker** и **docker compose**

Запуск (выполнять в директории с файлом docker-compose.yml):
```
docker compose up -d
```

После развертывания БД будет доступна по пути:

```
http://<адрес хоста>:6333/dashboards
```

Коллекции находятся тут:
```
http://<адрес хоста>:6333/dashboard#/collections
```

## 4. Парсинг данных со списка нужных страниц и наполнение БД этими данными.

Парсинг осуществляется скриптом **pipeline_main.py** , но сам скрипт берет ссылки на страницы для парсинга из файла **urls.txt** . Заполняем файл *urls.txt* ссылками без кавычек и разделителей, в столбик.

```
Примечание к шагу.

Я при работе заметил, что данные с одних страниц преобразовываются корректно, а с других с ошибками.
Связано это с размером чанка установленного в скрипте и количеством метаданных на странице. 
Этот момент пока на стадии изучения.
```

В директории с проектом приложен файл **parser.py** который выполняет рекурсивный парсинг заданного сайта (т.е. парсер проходит по ссылке которую ему дают и начинает собирать все адреса на сайте ведущие на различные страницы) и сохраняет результаты в файл **urls.txt**. Чтобы воспользоваться скриптом нужно сделать следуюзее:

Установить зависимости для парсера:
```
pip install requests beautifulsoup4
```

Затем изменить это значение в скрипте на свою ссылку:
```
DOMAIN = "https://ваш-сайт.com"
```

Запустить выполнение:
```
python3 parser.py
```

```
Примечание к шагу.

Ссылок будет оооооооочень много, я не знаю как их обработает скрипт наполнения БД потом )))
```

### Запускаем скрипт парсинга и наполнения БД.
Взаимодействие со скриптом pipeline_main.py: При запуске скрипта необходимо использовать флаги **--collection-name** (в нем задается название будущей коллекции в БД qdrant), и **--qdrant-host** (в нем задается адрес БД qdrant в которую мы будем сохранять данные).

Пример запуска скрипта:
```
python3 pipeline_main.py --collection-name web_knowledge --qdrant-host 127.0.0.1
```
По-умолчанию (если запустить скрипт без указания флагов) будет использоваться имя "test-collection" и адрес "127.0.0.1"

### Где в QDRANT смотреть коллекции

По адресу *http://<адрес хоста QDRANT>:6333/dashboard#/collections*

Пример:
```
http://127.0.0.1:6333/dashboard#/collections
```

## 5. Запуск бота, который будет отвечать на вопросы обращаясь к данным в развернутой БД.

### Небольшое введение

Чтобы чат заработал нужна модель llm и окружение для ее запуска. В скрипте-боте я использовал Gemma3:1b это одна из наиболее сообразительных моделей при небольшом размере до 1 гб, и высокой скорости работы даже на голом среднем ЦП. Работать модель будет в окружении Ollama. 

### Подготовка

Установка окружения Ollama для Linux:
```
curl -fsSL https://ollama.com/install.sh | sh
```

Установка нужной модели:
```
ollama pull gemma3:1b
```

Взаимодействие со скриптом **chat-bot-gemma3_1b.py**: Запуск скрипта бота необходимо осуществлять в том же виртуальном окружении в котором ранее осуществлялся скрипт наполнения БД, так как в этом окружении уже есть все зависимости. 

Чтобы бот работал корректно нужно указать через флаги **--collection** и **--qdrant-host** имя коллекции в векторной БД и адрес хоста самой БД. Пример команды:
```
python3 chat-bot-gemma3_1b.py --collection web_knowledge --qdrant-host 127.0.0.1
```
По-умолчанию (если запустить скрипт без указания флагов) будут использоваться имя "test-collection" и адрес "localhost". Так что если скрипт **pipeline_main.py** запускался ранее без флагов, то и этот тоже можно.

```
Примечание к шагу.

Взаимодействие с Gemma3:1b обычно происходит очень быстро, почти молниеносно,
даже на слабых пк. В работе бота генерация ответов происходит довольно долго.
Этот вопрос также пока на стадии разбора.
```
